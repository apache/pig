/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Grammar for Grunt

options {
  // Generate non-static functions
  STATIC = false;
  // Case is ignored in keywords
  IGNORE_CASE = true;
}

PARSER_BEGIN(GruntParser)
package org.apache.pig.tools.grunt;

import java.io.IOException;
import java.util.Iterator;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.FileUtil;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.FileStatus;

import org.apache.hadoop.mapred.JobClient;
import org.apache.hadoop.mapred.RunningJob; 

import org.apache.pig.PigServer;
import org.apache.pig.impl.PigContext;
import org.apache.pig.data.Tuple;

class GruntParser
{
	public void parseStopOnError() throws IOException, ParseException
	{
		prompt();
		mDone = false;
		while(!mDone)
			parse();
	}

	public void parseContOnError()
	{
		prompt();
		mDone = false;
		while(!mDone)
			try
			{
				parse();
			}
			catch(Exception e)
			{
				System.err.println(e.getMessage());
			}
	}

	public void setInteractive(boolean interactive)
	{
		mInteractive = interactive;
		token_source.interactive = interactive;
	}

	public void setParams(PigServer pigServer)
	{
		mPigServer = pigServer;
		mDfs = mPigServer.getPigContext().getDfs();
		mConf = mPigServer.getPigContext().getConf();
		mJobClient = mPigServer.getPigContext().getJobClient();
	}

	public void prompt()
	{
		if (mInteractive)
		{
			System.err.print("grunt> ");
			System.err.flush();
		}
	}

	private void processCat(String path) throws IOException
	{
		byte buffer[] = new byte[65536];
		Path dfsPath = new Path(path);
		int rc;
		
		if (!mDfs.exists(dfsPath))
			throw new IOException("Directory " + path + " does not exist.");

		if (mDfs.getFileStatus(dfsPath).isDir()) 
		{
			FileStatus fileStat[] = mDfs.listStatus(dfsPath);
			for (int j = 0; j < fileStat.length; j++)
			{
				Path curPath = fileStat[j].getPath();
				if (!mDfs.isFile(curPath)) continue;
				FSDataInputStream is = mDfs.open(curPath);
				while ((rc = is.read(buffer)) > 0)
					System.out.write(buffer, 0, rc);
				is.close();
			}
		} 
		else 
		{
			FSDataInputStream is = mDfs.open(dfsPath);
			while ((rc = is.read(buffer)) > 0)
				System.out.write(buffer, 0, rc);
			is.close();
		}
	}

	private void processCD(String path) throws IOException
	{	
		if (path == null)
			mDfs.setWorkingDirectory(new Path("/user/" + System.getProperty("user.name")));
		else
		{
			Path dfsDir = new Path(path);

			if (!mDfs.exists(dfsDir))
				throw new IOException("Directory " + path + " does not exist.");

			if (!mDfs.getFileStatus(dfsDir).isDir())
				throw new IOException(path + " is not a directory.");

			mDfs.setWorkingDirectory(dfsDir);
		}
	}

	private void processDump(String alias) throws IOException
	{
		Iterator result = mPigServer.openIterator(alias);
		while (result.hasNext())
		{
			Tuple t = (Tuple) result.next();
			System.out.println(t);
		}
	}

	private void processKill(String jobid) throws IOException
	{
		RunningJob job = mJobClient.getJob(jobid);
		if (job == null)
			System.out.println("Job with id " + jobid + " is not active");
		else
		{	
			job.killJob();
			System.err.println("kill submited.");
		}
	}

	private void processLS(String path) throws IOException
	{
		Path dir;
		if(path == null)
                	dir = mDfs.getWorkingDirectory();
		else
		{
			dir = new Path(path);
			if (!mDfs.exists(dir))
				throw new IOException("File or directory " + path + " does not exist.");
		}

		FileStatus fileStat[] = mDfs.listStatus(dir);
		for (int j = 0; j < fileStat.length; j++)
		{
            if (fileStat[j].isDir())
           		System.out.println(fileStat[j].getPath() + "\t<dir>");
			else
				System.out.println(fileStat[j].getPath() + "<r " + fileStat[j].getReplication() + ">\t" + fileStat[j].getLen());
                }
	}

	private void printHelp() 
	{
		System.err.println("Commands:");
		System.err.println("<pig latin statement>;");
		System.err.println("store <alias> into <filename> [using <functionSpec>]");
		System.err.println("dump <alias>");
		System.err.println("describe <alias>");
		System.err.println("kill <job_id>");
		System.err.println("ls <path>\r\ndu <path>\r\nmv <src> <dst>\r\ncp <src> <dst>\r\nrm <src>");
		System.err.println("copyFromLocal <localsrc> <dst>\r\ncd <dir>\r\npwd");
		System.err.println("cat <src>\r\ncopyToLocal <src> <localdst>\r\nmkdir <path>");
		System.err.println("cd <path>");
		System.err.println("define <functionAlias> <functionSpec>");
		System.err.println("register <udfJar>");
		System.err.println("set key value");
		System.err.println("quit");
	}

	private void processMove(String src, String dst) throws IOException
	{
		Path srcPath = new Path(src);
		Path dstPath = new Path(dst);
		if (!mDfs.exists(srcPath))
			throw new IOException("File or directory " + src + " does not exist.");

		{mDfs.rename(srcPath, dstPath);}
	}

	private void processPig(String cmd) throws IOException
	{
		if (cmd.charAt(cmd.length() - 1) != ';') 
			mPigServer.registerQuery(cmd + ";"); 
		else 
			mPigServer.registerQuery(cmd);
	}

	private void processRemove(String path) throws IOException
	{
		Path dfsPath = new Path(path);
		if (!mDfs.exists(dfsPath))
			throw new IOException("File or directory " + path + " does not exist.");

		mDfs.delete(dfsPath);
	}

	 static String unquote(String s)
	{
		if (s.charAt(0) == '\'' && s.charAt(s.length()-1) == '\'')
			return s.substring(1, s.length()-1);
		else
			return s;
	}


	private boolean mInteractive;
	private PigServer mPigServer;
	private FileSystem mDfs;
	private Configuration mConf;
	private JobClient mJobClient;
	private boolean mDone;

}
PARSER_END(GruntParser)

// Skip all tabs and spaces
SKIP : { " " |  "\t" }

// Skip comments(single line and multiline)
SKIP : {
   <"--"(~["\r","\n"])*>
|  <"/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// tokens

// commands
TOKEN: {<CAT: "cat">}
TOKEN: {<CD: "cd">}
TOKEN: {<COPY: "cp">}
TOKEN: {<COPYFROMLOCAL: "copyFromLocal">}
TOKEN: {<COPYTOLOCAL: "copyToLocal">}
TOKEN: {<DEFINE: "define">}
TOKEN: {<DUMP: "dump">}
TOKEN: {<DESCRIBE: "describe">}
TOKEN: {<HELP: "help">}
TOKEN: {<KILL: "kill">}
TOKEN: {<LS: "ls">}
TOKEN: {<MOVE: "mv">}
TOKEN: {<MKDIR: "mkdir">}
TOKEN: {<PWD: "pwd">}
TOKEN: {<QUIT: "quit">}
TOKEN: {<REGISTER: "register">}
TOKEN: {<REMOVE: "rm">}
TOKEN: {<SET: "set">}
TOKEN: {<STORE: "store">}
TOKEN: {<INTO: "into">}
TOKEN: {<USING: "using">}

// internal use commands
TOKEN: {<SCRIPT_DONE: "scriptDone">}

// Define pig command as 
// (1) Starting with "split" or assignment (A=) followed by
// (2) Single statement followed by ; and newline or
// (3) Block of statements enclosed in

TOKEN_MGR_DECLS : {
        int pigBlockLevel = 0;
        int funcBlockLevel = 0;
	int prevState = DEFAULT;
	boolean interactive = false;
	public void secondary_prompt()
	{
		if (interactive)
		{
			System.err.print(">> ");
			System.err.flush();
		}
	}

}

<DEFAULT> MORE :
{
	<"split"> : PIG_START
| 	<"("> : FUNC_ARGS_START
| 	<(["a"-"z", "A"-"Z"])+(["a"-"z", "A"-"Z"] | ["0"-"9"] | "_")*(" " | "\t")*"="> : PIG_START
}

<PIG_START> MORE :
{
	<"'"> {prevState = PIG_START;} : IN_STRING
|       <"{"> {pigBlockLevel = 1;} : IN_BLOCK
|       <"}"> {if (true) throw new TokenMgrError("Unmatched '}'", TokenMgrError.LEXICAL_ERROR);}
|       <";"> : PIG_END
|	<"--"> {prevState = PIG_START;} : SINGLE_LINE_COMMENT
|	<"/*"> {prevState = PIG_START;} : MULTI_LINE_COMMENT
|	<("\n" | "\r" | "\r\n")> {secondary_prompt();}
|       <(~[])>
}

<SINGLE_LINE_COMMENT> MORE :
{
	<("\n" | "\r" | "\r\n")> {SwitchTo(prevState); if(prevState != DEFAULT) secondary_prompt();}
|       <(~[])>
}

<MULTI_LINE_COMMENT> MORE :
{
	<"*/"> {SwitchTo(prevState);}
|	<("\n" | "\r" | "\r\n")> {secondary_prompt();}
|       <(~[])>
}

<IN_STRING> MORE :
{
	<"'"> { SwitchTo(prevState);}
|	<("\n" | "\r" | "\r\n")> {secondary_prompt();}
|	<(~[])>
}

<IN_BLOCK> MORE :
{
	<"\""> {prevState = IN_BLOCK;} : IN_STRING
|	<"{"> {pigBlockLevel++;}
|       <"}"(";")?> {pigBlockLevel--; if (pigBlockLevel == 0) SwitchTo(PIG_END);}
|	<"'"> {prevState = IN_BLOCK;} : IN_STRING
|	<"--"> {prevState = IN_BLOCK;} : SINGLE_LINE_COMMENT
|	<"/*"> {prevState = IN_BLOCK;} : MULTI_LINE_COMMENT
|	<("\n" | "\r" | "\r\n")> {secondary_prompt();}
|       <(~[])>
}

<PIG_END> TOKEN :
{
        <PIG: ""> { 	matchedToken.image = image.toString();
			//System.out.println("image = " +  matchedToken.image);
		}: DEFAULT
}

<FUNC_ARGS_START> MORE :
{
	<"("> {funcBlockLevel = 1;} : IN_ARG_BLOCK
|	<")"> : FUNC_ARGS_END
|	<(~[])>
}

<IN_ARG_BLOCK> MORE:
{
        <"("> {funcBlockLevel++;}
|       <")"> {funcBlockLevel--; if (funcBlockLevel == 0) SwitchTo(FUNC_ARGS_END);}
|       <(~[])>
}

<FUNC_ARGS_END> TOKEN :
{
        <FUNC_ARGS: ""> {matchedToken.image = image.toString();}: DEFAULT
}

// other
TOKEN: {<EOL:  "\r" | "\n" | "\r\n">}
TOKEN: {<QUOTE: "'">}
TOKEN: {<SEMICOLON: ";">}
TOKEN:
{
	<#LETTER : ["a"-"z", "A"-"Z"] >
|	<#DIGIT : ["0"-"9"] >
|	<#SPECIALCHAR : ["_"] >
|	<#FSSPECIALCHAR: ["/"]>
|       <#FLOAT: <INTEGER> ( "." <INTEGER> )? | "." <INTEGER> >
|       <#INTEGER: ( <DIGIT> )+ >
|	<#NUMBER: <INTEGER> | <FLOAT> | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?>
}

TOKEN: {<IDENTIFIER: (<LETTER>)+(<DIGIT> | <LETTER> | <SPECIALCHAR>)*>}
TOKEN: {<PATH: (~["(", ")", ";", "\r", " ", "\t", "\n"])+>}
TOKEN : { <QUOTEDSTRING : "'" (~["'"])* "'"> }
void parse() throws IOException:
{
	Token t1, t2;
	String val = null;
}

{
	(	
	<EOL>
	{prompt();}
	|
	<CAT>
	(
	t1 = GetPath()
	{processCat(t1.image);}		
	)+
	|
	<CD>
	(
		t1 = GetPath()
		{processCD(t1.image);}
		|
		{processCD(null);}
	)
	|
	<COPY>
	t1 = GetPath()
	t2 = GetPath()
	{FileUtil.copy(mDfs, new Path(t1.image), mDfs, new Path(t2.image), false, mConf);}	
	|
	<COPYFROMLOCAL>
	t1 = GetPath()
	t2 = GetPath()
	{mDfs.copyFromLocalFile(new Path(t1.image), new Path(t2.image));}	
	|
	<COPYTOLOCAL>
	t1 = GetPath()
	t2 = GetPath()
	{mDfs.copyToLocalFile(new Path(t1.image), new Path(t2.image));}	
	|
	<DEFINE>
	t1 = <IDENTIFIER>
	(
	val = QualifiedFunction()
	)
	{mPigServer.registerFunction(t1.image, val);}
	|
	<DUMP>
	t1 = <IDENTIFIER>
	{processDump(t1.image);}
	|
	<DESCRIBE>
	t1 = <IDENTIFIER>
	{mPigServer.dumpSchema(t1.image);}
	|
	<HELP>
	{printHelp();}
	|
	<KILL>
	t1 = <IDENTIFIER>	
	{processKill(t1.image);}
	|
	<LS>
	(
		t1 = GetPath()
		{processLS(t1.image);}
		|
		{processLS(null);}
	)
	|
	<MOVE>
	t1 = GetPath()
	t2 = GetPath()
	{processMove(t1.image, t2.image);}
	|
	<MKDIR>
	t1 = GetPath()
	{mDfs.mkdirs(new Path(t1.image));}
	|
	t1 = <PIG>
	{processPig(t1.image);}
	|
	<PWD>
	{System.out.println(mDfs.getWorkingDirectory());}
	|
	<QUIT>
	{System.exit(0);}
	|
	<REGISTER>
	t1 = GetPath()
	{mPigServer.registerJar(t1.image);}
	|
	<REMOVE>
	(
		t1 = GetPath()
		{processRemove(t1.image);}
	)+	
	|
	<SCRIPT_DONE>
	{mDone = true;}
	|
	<SET>
	(
		t1 = GetKey()
		t2 = GetValue()
		{
			if (t1.image.equals("debug"))
			{
				if (t2.image.equals("on") || t2.image.equals("'on'"))
					mPigServer.debugOn();
				else if (t2.image.equals("off") || t2.image.equals("'off'"))
					mPigServer.debugOff();
				else
					throw new ParseException("Invalid value " + t2.image + " provided for " + t1.image);
			}
			else if (t1.image.equals("job.name"))
			{
				//mPigServer.setJobName(unquote(t2.image));
				mPigServer.setJobName(t2.image);
			}
			else
			{
				// other key-value pairs can go there
				// for now just throw exception since we don't support
				// anything else
				throw new ParseException("Unrecognized set key: " + t1.image);
			}
		}
	)
	|
	<STORE>
	t1 = <IDENTIFIER>
	<INTO>
	t2 = GetPath()
	(
		<USING>
		val = QualifiedFunction()
	)?
	{mPigServer.store(t1.image, unquote(t2.image), val);} 
	|
	<EOF>
	{System.exit(0);}
	|
	<SEMICOLON>
	{}
	|
	// handle invalid token
	skip_invalid_command(EOL)
	{prompt();}
	)
}

String QualifiedFunction()       : {Token t1;StringBuffer s=new StringBuffer();}
{
	t1 = GetPath()
	{s.append(t1.image);}
	(
		t1 = <FUNC_ARGS>
		{s.append(t1.image);}
	)*
        {return s.toString();}
}

Token GetPath() :
{
	Token t;
}
{
	(
	t = <IDENTIFIER>
	|
        t = <PATH>
	|
	t = GetReserved()
	)
	{return t;}
}

Token GetKey() :
{	
	Token t;
}
{
	t = GetPath()
	{return t;}
}

Token GetValue() :
{
	Token t;
}
{
	(
	t = GetPath()
	|
	t = <QUOTEDSTRING>
	)

	{return t;}
}

Token GetReserved () :
{
	Token t;
}
{
	(
	t = <CAT>
	|
	t = <CD>
	|
	t = <COPY>
	|
	t = <COPYFROMLOCAL>
	|
	t = <COPYTOLOCAL>
	|
	t = <DEFINE>
	|
	t = <DUMP>
	|
	t = <DESCRIBE>
	|
	t = <HELP>
	|
	t = <KILL>
	|
	t = <LS>
	|
	t = <MOVE>
	|
	t = <MKDIR>
	|
	t = <PWD>
	|
	t = <QUIT>
	|
	t = <REGISTER>
	|
	t = <REMOVE>
	|
	t = <SET>
	|
	t = <STORE>
	|
	t = <INTO>
	|
	t = <USING>
	|
	t = <SCRIPT_DONE>
	)

	{return t;}
}


JAVACODE 
void skip_invalid_command(int kind) 
{
	ParseException e = generateParseException();  // generate the exception object.
	System.out.println(e.toString());  // print the error message
	Token t = getNextToken();

	while (t.kind != kind)
		t = getNextToken();
}
